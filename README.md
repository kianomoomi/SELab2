## تغییرات داده شده برای گام ۱
-  تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع سفارش جدید اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع پرداخت تلفنی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان phone Order Payment</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع ثبت سفارش تلفتی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان phone Order Payment</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p>Phone Order Service</p>
</td>
<td width="141">
<p>افزودن کلاس PhoneOrderService</p>
</td>
<td width="292">
<p>یک کلاس برای ثبت و پرداخت تلفنی که اینترفیس Order Service را پیاده‌سازی می‌کند</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p>Phone Order Service</p>
</td>
<td width="141">
<p>افزودن توابعی که اینترفیس Order Service فراهم می‌کند. </p>
</td>
<td width="292">
<p>توابع PhoneOrderRegister و PhoneOrderPayment دارای پیاده‌سازی هستند و سایر توابع بدنه خالی دارند</p>
</td>
</tr>
    <tr>
<td width="64">
<p><strong>۵</strong></p>
</td>
<td width="198">
<p>Online Order Service</p>
</td>
<td width="141">
<p>افزودن توابع مربوط به Phone Register and Phone Payment </p>
</td>
<td width="292">
<p>توابع جدیدی که به اینترفیس OrderService اضافه شدند باید در اینجا نیز Override بشوند (هرچند با بدنه خالی).</p>
</td>
</tr>
    <tr>
<td width="64">
<p><strong>۶</strong></p>
</td>
<td width="198">
<p>OnSite Order Service</p>
</td>
<td width="141">
<p> افزودن توابع مربوط به Phone Register and Phone Payment </p>
</td>
<td width="292">
<p>توابع جدیدی که به اینترفیس OrderService اضافه شدند باید در اینجا نیز Override بشوند (هرچند با بدنه خالی).</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۷</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>افزودن قابلیت انتخاب روش پرداخت تلفنی</p>
</td>
<td width="292">
<p>در قسمت انتخاب روش پرداخت حالت دیگری برای پرداخت تلفنی ایجاد می‌کنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۸</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>افزودن پرداخت تلفنی</p>
</td>
<td width="292">
<p>چک کردن اینکه orderService اگر instance کلاس PhoneOrderService باشد را اضافه می‌کنیم. سپس مبلغ به صورت تلفنی پرداخت می‌شود.</p>
</td>
</tr>
</tbody>
</table>

مجموع تعداد تغییرات: .......۸.......
## تغییرات در گام ۲
### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:
<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>در سایر کلاس‌ها می‌توان گفت تقریبا این اصل رعایت شده و تخلف شدیدی صورت نگرفته</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>اینترفیس OrderService دارای توابعی است که هم مربوط به ثبت و هم مربوط به پرداخت است. بهتر است توابع هر یک از این دو کاربرد در اینترفیس‌های جدا تعریف شود.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>جز قسمت Order Service در بقیه‌ی جا‌ها تقریبا این مورد را داریم و مشکلی وجود ندارد.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>اگر یک حالت جدید payment اضافه شود مثل الان که مثلا Phone Order Service اضافه شده است، مجبوریم interface هارا آپدیت کنیم و وقتی interface آپدیت می‌شود کلاس‌های مربوطه به Onsite و Online نیز مجبور می‌شوند این توابع را override کنند. پس این برنامه‌ی ما open به تغییرات و اضافه کردن و extensionها نیست. و برای فیچر‌ اضافه کردن مجبوریم تا خیلی از جاها را تفییر دهیم.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کلاس‌های OnlineOrderService و OnSiteOrderService و PhoneOrderService می‌توانند به‌جای اینترفیس پدر خود یعنی OrderService استفاده شوند و بنابراین این اصل رعایت شده است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>تخلفی برای این اصل رخ نداده است.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>این اصل محقق نشده است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>اینترفیس OrderService شامل توابعی است که هم برای ثبت سفارش و هم برای پرداخت استفاده می‌شوند. بنابراین کلاس‌های استفاده‌کننده از آن مجبور می‌شوند همه این توابع را پیاده‌سازی کنند، حتی اگر بعضی از آن‌ها را نیاز نداشته باشند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کلاس Main وابسته به اینترفیس سطح بالا Order Service می‌باشد و وابسته به کلاس‌های سطح پایین‌تر آن نمی‌باشد.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای این اصل تخلف شدیدی رخ نداده است.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:
<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>
<tr>
<td width="168">
<p>SRP</p>
</td>
<td width="246">
<p>اینترفیس OrderService دارای توابعی است که هم برای ثبت سفارش و هم برای پرداخت استفاده می‌شوند.</p>
</td>
<td width="284">
<p>یک اینترفیس برای پرداخت داشته باشیم و یک اینترفیس دیگر برای ثبت سفارش</p>
</td>
</tr>
<tr>
<td width="168">
<p>OCP</p>
</td>
<td width="246">
<p>وقتی به اینترفیس OrderService توابع مربوط به ثبت و پرداخت تلفنی را اضافه کردیم، کلاس‌های OnlineOrderService و OnsiteOrderService نیز مجبور شدند توابع جدید را Override کنند. هرچند که به آن‌ها نیازی نداشتند و با بدنه خالی آن‌ها را پیاده‌سازی کردند.</p>
</td>
<td width="284">
<p>یک اینترفیس برای پرداخت داشته باشیم که فقط یک تابع پرداخت کلی دارد و هر کلاسی که این اینترفیس را پیاده‌سازی می‌کند، بر اساس نوع خود نوع پرداخت مناسب را انتخاب کند و آن را پیاده‌سازی کند. برای ثبت سفارش نیز به همین‌گونه عمل می‌کنیم. در این صورت اگر نوع جدیدی از ثبت سفارش و پرداخت نیز اضافه شود، کلاس‌های دیگر لازم نیست تغییر کنند.</p>
</td>
</tr>
<tr>
<td width="168">
<p>ISP</p>
</td>
<td width="246">
<p>همه کلاس‌ها باید همه توابع موجود در اینترفیس OrderService را پیاده‌سازی می‌کردند. در صورتی که به همه آن‌ها نیازی نداشتند و بدنه برخی از توابع خالی می‌ماند.</p>
</td>
<td width="284">
<p>همانطور که بالاتر اشاره شد، در اینترفیس مربوط به پرداخت تنها یک تابع پرداخت وجود داشته باشد و سایر کلاس‌ها هنگام Override کردن این تابع، نوع پرداخت مناسب را پیاده‌سازی کنند. برای ثبت سفارش نیز همین‌گونه است.</p>
</td>
</tr>
</tbody>
</table>

## گام ۴
### سوال ۱:  
پس از انجام تغییرات در کد، دیگر تغییرات شماره ۱ و ۲ در جدول بالا معتبر نیستند. زیرا با توجه به دو اینترفیس جدیدی که طراحی کردیم، اضافه کردن یک روش دیگر آن‌ها را تغییر نخواهد داد. تغییرات ۳ و ۴ را همچنان خواهیم داشت زیرا باید کلاس مربوطه را ایجاد کنیم و توابع دو اینترفیس را پیاده‌سازی کنیم. تغییرات ۵ و ۶ نیز دیگر معتبر نیستند زیرا کلاس‌های دیگر لازم نیست تا تغییر کنند. در روش جدید هر کلاس فقط لازم است تا دو تابع اینترفیس‌ها را متناسب با نوع خودش پیاده‌سازی کند. تغییر ۷ همچنان لازم است. زیرا همچنان باید قابلیت انتخاب روش پرداخت تلفنی به برنامه اضافه شود.
تغییر شماره ۸ نیز نیاز نیست زیرا دیگر روش‌های مختلف پرداخت توابع مختلفی نیاز ندارند و همگی از طریق اینترفیس اینکار را انجام می‌دهند.  
بنابراین پس از انجام تغییرات، تنها تغییرات شماره‌های ۳ و ۴ و ۷ همچنان نیاز خواهند بود.  
### سوال ۲:  
طبق توضیحات بالا به ۳ تغییر نیاز خواهیم داشت.  
## گام ۵  
استفاده از اصول SOLID کیفیت کد را بالا می‌برد و سیستم را maintainable‌تر می‌کند. همان‌طور که می‌دانیم یک برنامه زمانی می‌میرد که دیگر maintainable نباشد. استفاده از این اصول امکان ایجاد تغییر و اضافه کردن ویژگی‌های جدید به برنامه را به طور قابل توجهی آسان‌تر می‌سازد. این اصول کد را تمیز‌تر، استاندارد‌تر، قابل فهم‌تر و معمولا کوتاه‌تر می‌کند. این اصول یکی از فاکتور‌هایی است که یک مهندس نرم‌افزار را از یک دولوپر ساده متمایز می‌سازد.
